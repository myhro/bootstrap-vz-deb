.\" Man page generated from reStructuredText.
.
.TH "BOOTSTRAP-VZ" "3" "August 19, 2015" "0.9.5" "bootstrap-vz"
.SH NAME
bootstrap-vz \- bootstrap-vz Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
The manifest file is the primary way to interact with bootstrap\-vz.
Every configuration and customization of a Debian installation is specified in this file.
.sp
The manifest format is YAML or JSON. It is near impossible to run the
bootstrapper with an invalid configuration, since every part of the
framework supplies a \fI\%json\-schema\fP that
specifies exactly which configuration settings are valid in different
situations.
.SH MANIFEST VARIABLES
.sp
Many of the settings in the example manifests use strings like
\fBdebian\-{system.release}\-{system.architecture}\-
{{"{\%y"}}}{{"{\%m"}}}{{"{\%d"}}}\fP\&.
These strings make use of manifest variables, which can cross reference
other settings in the manifest or specific values supplied by the
bootstrapper (e.g. all python date formatting variables are available).
.sp
Any reference uses dots to specify a path to the desired manifest
setting. Not all settings support this though, to see whether embedding
a manifest variable in a setting is possible, look for the
\fBmanifest vars\fP label.
.SH SECTIONS
.sp
The manifest is split into 7 sections.
.SS Provider
.sp
The provider section contains all provider specific settings and the
name of the provider itself.
.INDENT 0.0
.IP \(bu 2
\fBname\fP: target virtualization platform of the installation
\fBrequired\fP
.UNINDENT
.sp
Consult the \fI\%providers\fP section of the documentation
for a list of valid values.
.SS Bootstrapper
.sp
This section concerns the bootstrapper itself and its behavior. There
are 4 possible settings:
.INDENT 0.0
.IP \(bu 2
\fBworkspace\fP: Path to where the bootstrapper should place images
and intermediate files. Any volumes will be mounted under that path.
\fBrequired\fP
.IP \(bu 2
\fBtarball\fP: debootstrap has the option to download all the
software and pack it up in a tarball. When starting the actual
bootstrapping process, debootstrap can then be pointed at that
tarball and use it instead of downloading anything from the internet.
If you plan on running the bootstrapper multiple times, this option
can save you a lot of bandwidth and time. This option just specifies
whether it should create a new tarball or not. It will search for and
use an available tarball if it already exists, regardless of this
setting.
\fBoptional\fP
Valid values: \fBtrue, false\fP
Default: \fBfalse\fP
.IP \(bu 2
\fBmirror\fP: The mirror debootstrap should download software from.
It is advisable to specify a mirror close to your location (or the
location of the host you are bootstrapping on), to decrease latency
and improve bandwidth. If not specified, \fI\%the configured aptitude
mirror URL\fP is used.
\fBoptional\fP
.IP \(bu 2
\fBinclude_packages\fP: Extra packages to be installed during
bootstrap. Accepts a list of package names.
\fBoptional\fP
.IP \(bu 2
\fBexclude_packages\fP: Packages to exclude during bootstrap phase.
Accepts a list of package names.
\fBoptional\fP
.IP \(bu 2
\fBguest_additions\fP: This setting is only relevant for the
\fI\%virtualbox provider\fP\&.
It specifies the path to the VirtualBox Guest Additions ISO, which, when specified,
will be mounted and used to install the VirtualBox Guest Additions.
\fBoptional\fP
.UNINDENT
.SS Image
.sp
The image section configures anything pertaining directly to the image
that will be created.
.INDENT 0.0
.IP \(bu 2
\fBname\fP: The name of the resulting image.
When bootstrapping cloud images, this would be the name visible in
the interface when booting up new instances.
When bootstrapping for VirtualBox or kvm, it\(aqs the filename of the
image.
\fBrequired\fP
\fBmanifest vars\fP
.IP \(bu 2
\fBdescription\fP: Description of the image. Where this setting is
used depends highly on which provider is set. At the moment it is
only used for AWS images.
\fBrequired for ec2 provider\fP
\fBmanifest vars\fP
.IP \(bu 2
\fBbucket\fP: When bootstrapping an S3 backed image for AWS, this
will be the bucket where the image is uploaded to.
\fBrequired for S3 backing\fP
.IP \(bu 2
\fBregion\fP: Region in which the AMI should be registered.
\fBrequired for S3 backing\fP
.UNINDENT
.SS System
.sp
This section defines anything that pertains directly to the bootstrapped
system and does not fit under any other section.
.INDENT 0.0
.IP \(bu 2
\fBarchitecture\fP: The architecture of the system.
Valid values: \fBi386, amd64\fP
\fBrequired\fP
.IP \(bu 2
\fBbootloader\fP: The bootloader for the system. Depending on the
bootmethod of the virtualization platform, the options may be
restricted.
Valid values: \fBgrub, extlinux, pv\-grub\fP
\fBrequired\fP
.IP \(bu 2
\fBcharmap\fP: The default charmap of the system.
Valid values: Any valid charmap like \fBUTF\-8\fP, \fBISO\-8859\-\fP or
\fBGBK\fP\&.
\fBrequired\fP
.IP \(bu 2
\fBhostname\fP: hostname to preconfigure the system with.
\fBoptional\fP
.IP \(bu 2
\fBlocale\fP: The default locale of the system.
Valid values: Any locale mentioned in \fB/etc/locale.gen\fP
\fBrequired\fP
.IP \(bu 2
\fBrelease\fP: Defines which debian release should be bootstrapped.
Valid values: \fBsqueeze\fP, \fBwheezy\fP, \fBjessie\fP, \fBsid\fP,
\fBoldstable\fP, \fBstable\fP, \fBtesting\fP, \fBunstable\fP
\fBrequired\fP
.IP \(bu 2
\fBtimezone\fP: Timezone of the system.
Valid values: Any filename from \fB/usr/share/zoneinfo\fP
\fBrequired\fP
.UNINDENT
.SS Packages
.sp
The packages section allows you to install custom packages from a
variety of sources.
.INDENT 0.0
.IP \(bu 2
\fBinstall\fP: A list of strings that specify which packages should
be installed. Valid values: package names optionally followed by a
\fB/target\fP or paths to local \fB\&.deb\fP files.
.IP \(bu 2
\fBinstall_standard\fP: Defines if the packages of the
\fB"Standard System Utilities"\fP option of the Debian installer,
provided by \fI\%tasksel\fP, should be
installed or not. The problem is that with just \fBdebootstrap\fP, the
system ends up with very basic commands. This is not a problem for a
machine that will not be used interactively, but otherwise it is nice
to have at hand tools like \fBbash\-completion\fP, \fBless\fP, \fBlocate\fP,
etc.
\fBoptional\fP
Valid values: \fBtrue\fP, \fBfalse\fP
Default: \fBfalse\fP
.IP \(bu 2
\fBmirror\fP: The default aptitude mirror.
\fBoptional\fP
Default: \fBhttp://http.debian.net/debian\fP
.IP \(bu 2
\fBsources\fP: A map of additional sources that should be added to
the aptitude sources list. The key becomes the filename in
\fB/etc/apt/sources.list.d/\fP (with \fB\&.list\fP appended to it), while
the value is an array with each entry being a line.
\fBoptional\fP
.IP \(bu 2
\fBcomponents\fP: A list of components that should be added to the
default apt sources. For example \fBcontrib\fP or \fBnon\-free\fP
\fBoptional\fP
Default: \fB[\(aqmain\(aq]\fP
.IP \(bu 2
\fBtrusted\-keys\fP: List of paths to \fB\&.gpg\fP keyrings that should
be added to the aptitude keyring of trusted signatures for
repositories.
\fBoptional\fP
.IP \(bu 2
\fBpreferences\fP: Allows you to pin packages through \fI\%apt
preferences\fP\&. The setting
is an object where the key is the preference filename in
\fB/etc/apt/preferences.d/\fP\&. The key \fBmain\fP is special and refers
to the file \fB/etc/apt/preferences\fP, which will be overwritten if
specified.
\fBoptional\fP
The values are objects with three keys:
.IP \(bu 2
\fBpackage\fP: The package to pin (wildcards allowed)
.IP \(bu 2
\fBpin\fP: The release to pin the package to.
.IP \(bu 2
\fBpin\-priority\fP: The priority of this pin.
.UNINDENT
.SS Volume
.sp
bootstrap\-vz allows a wide range of options for configuring the disk
layout of the system. It can create unpartitioned as well as partitioned
volumes using either the gpt or msdos scheme. At most, there are only
three partitions with predefined roles configurable though. They are
boot, root and swap.
.INDENT 0.0
.IP \(bu 2
\fBbacking\fP: Specifies the volume backing. This setting is very
provider specific.
Valid values: \fBebs\fP, \fBs3\fP, \fBvmdk\fP, \fBvdi\fP, \fBraw\fP
\fBrequired\fP
.IP \(bu 2
\fBpartitions\fP: A map of the partitions that should be created on
the volume.
.IP \(bu 2
\fBtype\fP: The partitioning scheme to use. When using \fBnone\fP,
only root can be specified as a partition.
Valid values: \fBnone\fP, \fBgpt\fP, \fBmsdos\fP
\fBrequired\fP
.IP \(bu 2
\fBroot\fP: Configuration of the root partition. \fBrequired\fP
.INDENT 2.0
.IP \(bu 2
\fBsize\fP: The size of the partition. Valid values: Any
datasize specification up to TB (e.g. 5KiB, 1MB, 6TB).
\fBrequired\fP
.IP \(bu 2
\fBfilesystem\fP: The filesystem of the partition. When choosing
\fBxfs\fP, the \fBxfsprogs\fP package will need to be installed.
Valid values: \fBext2\fP, \fBext3\fP, \fBext4\fP, \fBxfs\fP
\fBrequired\fP
.IP \(bu 2
\fBformat_command\fP: Command to format the partition with. This
optional setting overrides the command bootstrap\-vz would normally
use to format the partition. The command is specified as a string
array where each option/argument is an item in that array (much
like the \fI\%commands\fP plugin).
\fBoptional\fP The following variables are available:
.IP \(bu 2
\fB{fs}\fP: The filesystem of the partition.
.IP \(bu 2
\fB{device_path}\fP: The device path of the partition.
.IP \(bu 2
\fB{size}\fP: The size of the partition.
.UNINDENT
.sp
The default command used by boostrap\-vz is
\fB[\(aqmkfs.{fs}\(aq, \(aq{device_path}\(aq]\fP\&.
.INDENT 2.0
.IP \(bu 2
\fBboot\fP: Configuration of the boot partition. The three
settings equal those of the root partition.
\fBoptional\fP
.IP \(bu 2
\fBswap\fP: Configuration of the swap partition. Since the swap
partition has its own filesystem you can only specify the size for
this partition.
\fBoptional\fP
.UNINDENT
.UNINDENT
.SS Plugins
.sp
The plugins section is a map of plugin names to whatever configuration a
plugin requires. Go to the \fI\%plugin section\fP
of the documentation, to see the configuration for a specific plugin.
.SH AZURE
.sp
This provider generates raw images for Microsoft Azure computing
platform.
.SS Setup
.sp
qemu\-img >= 1.7.0 required to convert raw image to vhd fixed size disk.
This release is available in wheezy\-backports.
.sp
\fIwget\fP must be installed on local computer.
.sp
Manifest must use the \fIraw\fP format, provider will automatically
transform the disk to a vhd disk format.
.sp
Do not create swap space on the OS disk:
.sp
The Windows Azure Linux Agent can automatically configure swap space
using the local resource disk that is attached to the VM after
provisioning on Azure. Modify the following parameters in
/etc/waagent.conf appropriately:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ResourceDisk.Format=y
ResourceDisk.Filesystem=ext4
ResourceDisk.MountPoint=/mnt/resource
ResourceDisk.EnableSwap=y
ResourceDisk.SwapSizeMB=2048    ## NOTE: set this to whatever you need it to be.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can specify a waagent.conf file to replace the default one in the
manifest in the azure/waagent section of the provider:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"system" : {
    "waagent" : {
       "conf": "path_to_my_conf_file",  # optional
       "version" : "2.0.4"              # mandatory
    }
}, ...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Waagent versions are available at:
\fI\%https://github.com/Azure/WALinuxAgent/releases\fP
.SH EC2
.sp
The \fI\%EC2\fP provider automatically creates
a volume for bootstrapping (be it EBS or S3), makes a snapshot of it
once it is done and registers it as an AMI. EBS volume backing only
works on an EC2 host while S3 backed volumes \fIshould\fP work locally (at
this time however they do not, a fix is in the works).
.sp
Unless \fI\%the cloud\-init plugin\fP
is used, special startup scripts will be installed that automatically fetch the
configured authorized_key from the instance metadata and save or run
any userdata supplied (if the userdata begins with \fB#!\fP it will be
run).
.SS Credentials
.sp
The AWS credentials can be configured in two ways: Via the manifest or
through environment variables. To bootstrap S3 backed instances you will
need a user certificate and a private key in addition to the access key
and secret key, which are needed for bootstraping EBS backed instances.
.sp
The settings describes below should be placed in the \fBcredentials\fP key
under the \fBprovider\fP section.
.INDENT 0.0
.IP \(bu 2
\fBaccess\-key\fP: AWS access\-key.
May also be supplied via the environment variable
\fB$AWS_ACCESS_KEY\fP
\fBrequired for EBS & S3 backing\fP
.IP \(bu 2
\fBsecret\-key\fP: AWS secret\-key.
May also be supplied via the environment variable
\fB$AWS_SECRET_KEY\fP
\fBrequired for EBS & S3 backing\fP
.IP \(bu 2
\fBcertificate\fP: Path to the AWS user certificate. Used for
uploading the image to an S3 bucket.
May also be supplied via the environment variable
\fB$AWS_CERTIFICATE\fP
\fBrequired for S3 backing\fP
.IP \(bu 2
\fBprivate\-key\fP: Path to the AWS private key. Used for uploading
the image to an S3 bucket.
May also be supplied via the environment variable
\fB$AWS_PRIVATE_KEY\fP
\fBrequired for S3 backing\fP
.IP \(bu 2
\fBuser\-id\fP: AWS user ID. Used for uploading the image to an S3
bucket.
May also be supplied via the environment variable \fB$AWS_USER_ID\fP
\fBrequired for S3 backing\fP
.UNINDENT
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\-\-\-
provider:
  name: ec2
  virtualization: hvm
  enhanced_networking: simple
  credentials:
    access\-key: AFAKEACCESSKEYFORAWS
    secret\-key: thes3cr3tkeyf0ryourawsaccount/FS4d8Qdva
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dependencies
.sp
To communicate with the AWS API \fI\%boto\fP
is required (version 2.14.0 or higher) you can install boto with
\fBpip install boto\fP (on wheezy, the packaged version is too low). S3
images are chopped up and uploaded using
\fI\%euca2ools\fP (install with
\fBapt\-get install euca2ools\fP).
.SH GOOGLE COMPUTE ENGINE
.sp
The \fI\%GCE\fP provider
can creates image as expected by GCE \- i.e. raw disk image in *.tar.gz
file. It can upload created images to Google Storage Engine (to URI
provided in manifest by \fBgcs_destination\fP) and can register image to
be used by Google Compute Engine to project provided in manifest by
\fBgce_project\fP\&. Both of those functionalities are not fully tested yet.
.SH KVM
.sp
The \fI\%KVM\fP provider creates
virtual images for Linux Kernel\-based Virtual Machines. It supports the
installation of \fI\%virtio kernel
modules\fP (paravirtualized
drivers for IO operations).
.SH VIRTUALBOX
.sp
The \fI\%VirtualBox\fP provider can bootstrap
to both .vdi and .vmdk images (raw images are also supported but do not
run in VirtualBox). It\(aqs advisable to always use vmdk images for
interoperability (e.g.
\fI\%OVF\fP files
\fIshould\fP support vdi files, but since they have no identifier URL not
even VirtualBox itself can import them). VirtualBox Guest Additions can
be installed automatically if the ISO is \fI\%provided in the
manifest\fP\&.
.sp
Providers in bootstrap\-vz represent various cloud providers and virtual machines.
.sp
bootstrap\-vz is an extensible platform with loose coupling and a significant
amount of tooling, which allows for painless implementation of new providers.
.sp
The virtualbox provider for example is implemented in only 89 lines of python,
since most of the building blocks are a part of the common task library.
Only the kernel and guest additions installation are specific to that provider.
.SH ADMIN USER
.sp
This plugin creates a user with passwordless sudo privileges. It also
disables the SSH root login. If the EC2 init scripts are installed, the
script for fetching the SSH authorized keys will be adjust to match the
username specified.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBusername\fP: The username of the account to create. \fBrequired\fP
.UNINDENT
.SH APT PROXY
.sp
This plugin creates a proxy configuration file for APT, so you could
enjoy the benefits of using cached packages instead of downloading them
from the mirror every time. You could just install \fBapt\-cacher\-ng\fP on
the host machine and then add \fB"address": "127.0.0.1"\fP and
\fB"port": 3142\fP to the manifest file.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBaddress\fP: The IP or host of the proxy server.
\fBrequired\fP
.IP \(bu 2
\fBport\fP: The port (integer) of the proxy server.
\fBrequired\fP
.IP \(bu 2
\fBusername\fP: The username for authentication against the proxy server.
This is ignored if \fBpassword\fP is not also set.
\fBoptional\fP
.IP \(bu 2
\fBpassword\fP: The password for authentication against the proxy server.
This is ignored if \fBusername\fP is not also set.
\fBoptional\fP
.IP \(bu 2
\fBpersistent\fP: Whether the proxy configuration file should remain on
the machine or not.
Valid values: \fBtrue\fP, \fBfalse\fP
Default: \fBfalse\fP\&.
\fBoptional\fP
.UNINDENT
.SH CLOUD-INIT
.sp
This plugin installs and configures
\fI\%cloud\-init\fP
on the system. Depending on the release it installs it from either
backports or the main repository.
.sp
cloud\-init is only compatible with Debian wheezy and upwards.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBusername\fP: The username of the account to create.
\fBrequired\fP
.IP \(bu 2
\fBdisable_modules\fP: A list of strings specifying which cloud\-init
modules should be disabled.
\fBoptional\fP
.IP \(bu 2
\fBmetadata_sources\fP: A string that sets the
\fI\%datasources\fP
that cloud\-init should try fetching metadata from. The source is
automatically set when using the ec2 provider.
\fBoptional\fP
.UNINDENT
.SH COMMANDS
.sp
This plugin allows you to run arbitrary commands during the bootstrap process.
The commands are run at an indeterminate point \fIafter\fP packages have been
installed, but \fIbefore\fP the volume has been unmounted.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBcommands\fP: A list of lists containing strings. Each top\-level item
is a single command, while the strings inside each list comprise
parts of a command. This allows for proper shell argument escaping.
To circumvent escaping, simply put the entire command in a single
string, the command will additionally be evaluated in a shell
(e.g. globbing will work).
In addition to the manifest variables \fB{root}\fP is also available.
It points at the root of the image volume.
\fBrequired\fP
\fBmanifest vars\fP
.UNINDENT
.SS Example
.sp
Create an empty \fIindex.html\fP in \fI/var/www\fP and delete all locales except english.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B commands:
.INDENT 7.0
.TP
.B commands:
.INDENT 7.0
.IP \(bu 2
[touch, \(aq{root}/var/www/index.html\(aq]
.IP \(bu 2
[\(aqrm \-rf /usr/share/locale/[^en]*\(aq]
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SH DOCKER DAEMON
.sp
Install \fI\%docker\fP daemon in the image. Uses
init scripts for the official repository.
.sp
This plugin can only be used if the distribution being bootstrapped is
at least \fBwheezy\fP, as Docker needs a kernel version \fB3.8\fP or higher,
which is available at the \fBwheezy\-backports\fP repository. There\(aqs also
an architecture requirement, as it runs only on \fBamd64\fP\&.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBversion\fP: Selects the docker version to install. To select the
latest version simply omit this setting.
Default: \fBlatest\fP
\fBoptional\fP
.UNINDENT
.SH MINIMIZE SIZE
.sp
This plugin can be used to reduce the size of the resulting image. Often
virtual volumes are much smaller than their reported size until any data
is written to them. During the bootstrapping process temporary data like
the aptitude cache is written to the volume only to be removed again.
.sp
The minimize size plugin employs three different strategies to keep a
low volume footprint:
.INDENT 0.0
.IP \(bu 2
Mount folders from the host into key locations of the image volume to
avoid any unneccesary disk writes.
.IP \(bu 2
Use \fI\%zerofree\fP to
deallocate unused sectors on the volume. On an unpartitioned volume
this will be done for the entire volume, while it will only happen on
the root partition for partitioned volumes.
.IP \(bu 2
Use
\fI\%vmware\-vdiskmanager\fP
to shrink the real volume size (only applicable when using vmdk
backing). The tool is part of the \fI\%VMWare
Workstation\fP
package.
.UNINDENT
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBzerofree\fP: Specifies if it should mark unallocated blocks as
zeroes, so the volume could be better shrunk after this.
Valid values: true, false
Default: false
\fBoptional\fP
.IP \(bu 2
\fBshrink\fP: Whether the volume should be shrunk. This setting works
best in conjunction with the zerofree tool.
Valid values: true, false
Default: false
\fBoptional\fP
.UNINDENT
.SH NTP
.sp
This plugins installs the Network Time Protocol daemon and optionally
defines which time servers it should use.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBservers\fP: A list of strings specifying which servers should be
used to synchronize the machine clock.
\fBoptional\fP
.UNINDENT
.SH OPEN NEBULA
.sp
This plugin adds \fI\%OpenNebula
contextualization\fP
to the image, which sets up the network configuration and SSH keys.
.sp
The virtual machine context should be configured as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ETH0_DNS      $NETWORK[DNS, NETWORK_ID=2]
ETH0_GATEWAY  $NETWORK[GATEWAY, NETWORK_ID=2]
ETH0_IP       $NIC[IP, NETWORK_ID=2]
ETH0_MASK     $NETWORK[MASK, NETWORK_ID=2]
ETH0_NETWORK  $NETWORK[NETWORK, NETWORK_ID=2]
FILES         path_to_my_ssh_public_key.pub
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The plugin will install all \fI\&.pub\fP files in the root authorized_keys
file. When using the ec2 provider, the USER_EC2_DATA will be executed
if present.
.SS Settings
.sp
This plugin has no settings. To enable it add \fB"opennebula":{}\fP to the
plugin section of the manifest.
.SH PIP INSTALL
.sp
Install packages from the Python Package Index via pip.
.sp
Installs \fBbuild\-essential\fP and \fBpython\-dev\fP debian packages, so
Python extension modules can be built.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBpackages\fP: Python packages to install, a list of strings. The list
can contain anything that \fBpip install\fP would accept as an
argument, for example \fBawscli==1.3.13\fP\&.
.UNINDENT
.SH PREBOOTSTRAPPED
.sp
When developing for bootstrap\-vz, testing can be quite tedious since the
bootstrapping process can take a while. The prebootstrapped plugin
solves that problem by creating a snapshot of your volume right after
all the software has been installed. The next time bootstrap\-vz is run,
the plugin replaces all volume preparation and bootstrapping tasks and
recreates the volume from the snapshot instead.
.sp
The plugin assumes that the users knows what he is doing (e.g. it
doesn\(aqt check whether bootstrap\-vz is being run with a partitioned
volume configuration, while the snapshot is unpartitioned).
.sp
When no snapshot or image is specified the plugin creates one and
outputs its ID/path. Specifying an ID/path enables the second mode of
operation which recreates the volume from the specified snapshot instead
of creating it from scratch.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBsnapshot\fP: ID of the EBS snapshot to use. This setting only works
with EBS backed EC2 configurations.
.IP \(bu 2
\fBimage\fP: Path to the loopbackvolume snapshot. This setting works
with all configurable volume backings except EBS.
.UNINDENT
.SH PUPPET
.sp
Installs \fI\%puppet\fP and optionally applies a
manifest inside the chroot. You can also have it copy your puppet
configuration into the image so it is readily available once the image
is booted.
.sp
Keep in mind that when applying a manifest, the system is in a chrooted
environment. This can prevent daemons from running properly (e.g.
listening to ports), they will also need to be shut down gracefully
(which bootstrap\-vz cannot do) before unmounting the volume. It is
advisable to avoid starting any daemons inside the chroot at all.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBmanifest\fP: Path to the puppet manifest that should be applied.
\fBoptional\fP
.IP \(bu 2
\fBassets\fP: Path to puppet assets. The contents will be copied into
\fB/etc/puppet\fP on the image. Any existing files will be overwritten.
\fBoptional\fP
.IP \(bu 2
\fBenable_agent\fP: Whether the puppet agent daemon should be enabled.
\fBoptional\fP
.UNINDENT
.SH ROOT PASSWORD
.sp
Sets the root password. This plugin removes the task that disables the
SSH password authentication.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBpassword\fP: The password for the root user.
\fBrequired\fP
.UNINDENT
.SH SALT
.sp
Install \fI\%salt\fP minion in the image. Uses
\fI\%salt\-bootstrap\fP script
to install.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBinstall_source\fP: Source to install salt codebase from. \fBstable\fP
for current stable, \fBdaily\fP for installing the daily build, and
\fBgit\fP to install from git repository.
\fBrequired\fP
.IP \(bu 2
\fBversion\fP: Only needed if you are installing from \fBgit\fP\&.
\fBdevelop\fP to install current development head, or provide any tag
name or commit hash from \fI\%salt
repo\fP
\fBoptional\fP
.IP \(bu 2
\fBmaster\fP: Salt master FQDN or IP
\fBoptional\fP
.IP \(bu 2
\fBgrains\fP: Set \fI\%salt
grains\fP
for this minion. Accepts a map with grain name as key and the grain
data as value.
\fBoptional\fP
.UNINDENT
.SH UNATTENDED UPGRADES
.sp
Enables the \fI\%unattended update/upgrade
feature\fP in
aptitude. Enable it to have your system automatically download and
install security updates automatically with a set interval.
.SS Settings
.INDENT 0.0
.IP \(bu 2
\fBupdate_interval\fP: Days between running \fBapt\-get update\fP\&.
\fBrequired\fP
.IP \(bu 2
\fBdownload_interval\fP: Days between running
\fBapt\-get upgrade \-\-download\-only\fP
\fBrequired\fP
.IP \(bu 2
\fBupgrade_interval\fP: Days between installing any security upgrades.
\fBrequired\fP
.UNINDENT
.SH VAGRANT
.sp
Vagrant is a tool to quickly create virtualized environments. It uses
"boxes" to make downloading and sharing those environments easier. A box
is a tarball containing a virtual volumes accompanied by an \fI\%OVF
specification\fP
of the virtual machine.
.sp
This plugin creates a vagrant box that is ready to be shared or
deployed. At the moment it is only compatible with the VirtualBox
provider and doesn\(aqt requires any additional settings.
.sp
Plugins are a key feature of bootstrap\-vz. Despite their small size
(most plugins do not exceed 100 source lines of code) they can modify
the behavior of bootstrapped systems to a great extent.
.sp
Below you will find documentation for all plugins available for
bootstrap\-vz. If you cannot find what you are looking for, consider
\fI\%developing it yourself\fP and
contribute to this list!
.sp
The following is a list of supported manifest combinations.
.sp
Note that grub cannot boot from unpartitioned volumes.
.sp
Additionally grub installation is not supported on \fIsqueeze\fP\&.
This is not a technical limitation, but simply stems from a
lack of motivation to implement support for it.
.SH AZURE
.sp
TODO
.SH EC2
.SS EBS (wheezy & jessie)
.TS
center;
|l|l|l|l|.
_
T{
Bootloader / Partitioning
T}	T{
none
T}	T{
msdos
T}	T{
gpt
T}
_
T{
pvgrub (paravirtualized)
T}	T{
supported
T}	T{
supported
T}	T{
supported
T}
_
T{
extlinux (hvm)
T}	T{
supported
T}	T{
supported
T}	T{
supported
T}
_
T{
grub (hvm)
T}	T{
\fInot supported\fP
T}	T{
supported
T}	T{
supported
T}
_
.TE
.SS EBS (squeeze)
.TS
center;
|l|l|l|l|.
_
T{
Bootloader / Partitioning
T}	T{
none
T}	T{
msdos
T}	T{
gpt
T}
_
T{
pvgrub (paravirtualized)
T}	T{
supported
T}	T{
supported
T}	T{
supported
T}
_
T{
extlinux (hvm)
T}	T{
supported
T}	T{
supported
T}	T{
supported
T}
_
T{
grub (hvm)
T}	T{
\fInot supported\fP
T}	T{
\fInot implemented\fP
T}	T{
\fInot implemented\fP
T}
_
.TE
.SS S3 (all releases)
.TS
center;
|l|l|l|l|.
_
T{
Bootloader / Partitioning
T}	T{
none
T}	T{
msdos
T}	T{
gpt
T}
_
T{
pvgrub (paravirtualized)
T}	T{
supported
T}	T{
\fInot implemented\fP
T}	T{
\fInot implemented\fP
T}
_
T{
extlinux (hvm)
T}	T{
\fInot implemented\fP
T}	T{
\fInot implemented\fP
T}	T{
\fInot implemented\fP
T}
_
T{
grub (hvm)
T}	T{
\fInot supported\fP
T}	T{
\fInot implemented\fP
T}	T{
\fInot implemented\fP
T}
_
.TE
.SH GCE
.sp
TODO
.SH KVM
.sp
TODO
.SH VIRTUALBOX
.TS
center;
|l|l|l|l|.
_
T{
Bootloader / Partitioning
T}	T{
none
T}	T{
msdos
T}	T{
gpt
T}
_
T{
extlinux
T}	T{
supported
T}	T{
supported
T}	T{
supported
T}
_
T{
grub
T}	T{
\fInot supported\fP
T}	T{
supported
T}	T{
supported
T}
_
.TE
.sp
Every run creates a new logfile in the \fBlogs/\fP directory. The filename
for each run consists of a timestamp (\fB%Y%m%d%H%M%S\fP) and the basename
of the manifest used. The log also contains debugging statements
regardless of whether the \fB\-\-debug\fP switch was used.
.sp
bootstrap\-vz is able to bootstrap images not only on the machine
on which it is invoked, but also on remote machines that have bootstrap\-vz
installed.
.sp
This is helpful when you create manifests on your own workstation, but have a
beefed up remote build server which can create images quickly.
There may also be situations where you want to build multiple manifests that
have different providers and require the host machines to be running on
that provider (e.g. EBS backed AMIs can only be created on EC2 instances),
when doing this multiple times SSHing into the machines and copying the
manifests can be a hassle.
.sp
Lastly, the main motivation for supporting remote bootstrapping is the
automation of \fI\%integration testing\fP\&.
As you will see \fI\%further down\fP,
bootstrap\-vz is able to select which build server is required
for a specific test and run the bootstrapping procedure on said server.
.SH BOOTSTRAP-VZ-REMOTE
.sp
Normally you\(aqd use \fBbootstrap\-vz\fP to start a bootstrapping process.
When bootstrapping remotely simply use \fBbootstrap\-vz\-remote\fP instead,
it takes the same arguments plus a few additional ones:
.INDENT 0.0
.IP \(bu 2
\fB\-\-servers <path>\fP: Path to a list of build\-servers
(see \fI\%build\-servers.yml\fP for more info)
.IP \(bu 2
\fB\-\-name <name>\fP: Selects a specific build\-server from the list
of build\-servers
.IP \(bu 2
\fB\-\-release <release>\fP: Restricts the autoselection of build\-servers
to the ones with the specified release
.UNINDENT
.sp
Much like when bootstrapping directly, you can press \fBCtrl+C\fP at any time
to abort the bootstrapping process.
The remote process will receive the keyboard interrupt signal
and begin cleaning up \- pressing \fBCtrl+C\fP a second time will abort that as
well and kill the connection immediately.
.sp
Note that there is also a \fBbootstrap\-vz\-server\fP, this file is not meant to be
invoked directly by the user, but is instead launched by bootstrap\-vz on the
remote server when connecting to it.
.SH DEPENDENCIES
.sp
For the remote bootstrapping procedure to work, you will need to install
bootstrap\-vz as well as the \fBsudo\fP command on the remote machine.
Also make sure that all the needed dependencies for bootstrapping your image
are installed.
.sp
Locally the pip package \fI\%Pyro4\fP is needed.
.SH BUILD-SERVERS.YML
.sp
The file \fBbuild\-servers.yml\fP informs bootstrap\-vz about the different
build servers you have at your disposal.
In its simplest form you can just add your own machine like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local:
  type: local
  can_bootstrap: [virtualbox]
  release: jessie
  build_settings: {}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBtype\fP specifies how bootstrap\-vz should connect to the build\-server.
\fBlocal\fP simply means that it will call the bootstrapping procedure directly,
no new process is spawned.
.sp
\fBcan_bootstrap\fP tells bootstrap\-vz for which providers this machine is capable
of building images. With the exception of the EC2 provider,
the accepted values match the accepted provider names in the manifest.
For EC2 you can specify \fBec2\-s3\fP and/or \fBec2\-ebs\fP\&.
\fBec2\-ebs\fP specifies that the machine in question can bootstrap EBS backed
images and should only be used when the it is located on EC2.
\fBec2\-s3\fP signifies that the machine is capable of bootstrapping S3 backed
images.
.sp
Beyond being a string, the value of \fBrelease\fP is not enforced in any way.
It\(aqs only current use is for \fBbootstrap\-vz\-remote\fP where you can restrict
which build\-server should be autoselected.
.SS Remote settings
.sp
The other (and more interesting) setting for \fBtype\fP is \fBssh\fP,
which requires a few more configuration settings:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local_vm:
  type: ssh
  can_bootstrap:
    \- virtualbox
    \- ec2\-s3
  release: wheezy
  # remote settings below here
  address: 127.0.0.1
  port: 2222
  username: admin
  keyfile: path_to_private_key_file
  server_bin: /root/bootstrap/bootstrap\-vz\-server
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The last 5 settings specify how bootstrap\-vz can connect
to the remote build\-server.
While the initial handshake is achieved through SSH, bootstrap\-vz mainly
communicates with its counterpart through RPC (the communication port is
automatically forwarded through an SSH tunnel).
\fBaddress\fP, \fBport\fP, \fBusername\fP and \fBkeyfile\fP are hopefully
self explanatory (remote machine address, SSH port, login name and path to
private SSH key file).
.sp
\fBserver_bin\fP refers to the \fI\%aboved mentioned\fP
bootstrap\-vz\-server executable. This is the command bootstrap\-vz executes
on the remote machine to start the RPC server.
.sp
Be aware that there are a few limitations as to what bootstrap\-vz is able to
deal with, regarding the remote machine setup (in time they may be fixed
by a benevolent contributor):
.INDENT 0.0
.IP \(bu 2
The login user must be able to execute sudo without a password
.IP \(bu 2
The private key file must be added to the ssh\-agent before invocation
(alternatively it may not be password protected)
.IP \(bu 2
The server must already be part of the known_hosts list
(bootstrap\-vz uses \fBssh\fP directly and cannot handle interactive prompts)
.UNINDENT
.SS Build settings
.sp
The build settings allow you to override specific manifest properties.
This is useful when for example the VirtualBox guest additions ISO is located
at \fB/root/guest_additions.iso\fP on server 1, while server 2 has it at
\fB/root/images/vbox.iso\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
local:
  type: local
  can_bootstrap:
    \- virtualbox
    \- ec2\-s3
  release: jessie
  build_settings:
    guest_additions: /root/images/VBoxGuestAdditions.iso
    apt_proxy:
      address: 127.0.0.1
      port: 3142
    ec2\-credentials:
      access\-key: AFAKEACCESSKEYFORAWS
      secret\-key: thes3cr3tkeyf0ryourawsaccount/FS4d8Qdva
      certificate: /root/manifests/cert.pem
      private\-key: /root/manifests/pk.pem
      user\-id: 1234\-1234\-1234
    s3\-region: eu\-west\-1
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBguest_additions\fP specifies the path to the VirtualBox guest additions ISO
on the remote machine.
.IP \(bu 2
\fBapt_proxy\fP sets the configuration for the \fIapt_proxy plugin <../plugins/apt_proxy>\fP\&.
.IP \(bu 2
\fBec2\-credentials\fP contains all the settings you know from EC2 manifests,
note that when running \fI\%integration tests\fP,
these credentials are also used when running instances.
.IP \(bu 2
\fBs3\-region\fP overrides the s3 bucket region when bootstrapping S3 backed images.
.UNINDENT

.SH DEVELOPING PLUGINS
.sp
Developing a plugin for bootstrap\-vz is a fairly straightforward process,
since there is very little code overhead.
.sp
The process is the same whether you create an \fI\%internal\fP
or an \fI\%external\fP plugin (though you need to add
some code for package management when creating an external plugin)
.sp
Start by creating an \fB__init__.py\fP in your plugin folder.
The only obligatory function you need to implement is \fBresolve_tasks()\fP\&.
This function adds tasks to be run to the tasklist:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def resolve_tasks(taskset, manifest):
        taskset\&.add(tasks\&.DoSomething)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The manifest variable holds the manifest the user specified,
with it you can determine settings for your plugin and e.g.
check of which release of Debian bootstrap\-vz will create an image.
.sp
A task is a class with a static \fBrun()\fP function and some meta\-information:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class DoSomething(Task):
        description = \(aqDoing something\(aq
        phase = phases\&.volume_preparation
        predecessors = [PartitionVolume]
        successors = [filesystem\&.Format]

        @classmethod
        def run(cls, info):
                pass
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To read more about tasks and their ordering, check out the section on
\fI\%how bootstrap\-vz works\fP\&.
.sp
Besides the \fBresolve_tasks()\fP function, there is also the \fBresolve_rollback_tasks()\fP
function, which comes into play when something has gone awry while bootstrapping.
It should be used to clean up anything that was created during the bootstrapping
process. If you created temporary files for example, you can add a task to the
rollback taskset that deletes those files, you might even already have it because
you run it after an image has been successfully bootstrapped:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def resolve_rollback_tasks(taskset, manifest, completed, counter_task):
        counter_task(taskset, tasks\&.DoSomething, tasks\&.UndoSomething)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In  \fBresolve_rollback_tasks()\fP you have access to the taskset
(this time it contains tasks that will be run during rollback), the manifest, and
the tasks that have already been run before the bootstrapping aborted (\fBcompleted\fP).
.sp
The last parameter is the \fBcounter_task()\fP function, with it you can specify that
a specific task (2nd param) has to be in the taskset (1st param) for the rollback
task (3rd param) to be added. This saves code and makes it more readable than
running through the completed tasklist and checking each completed task.
.sp
You can also specify a \fBvalidate_manifest()\fP function.
Typically it looks like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def validate_manifest(data, validator, error):
        import os.path
        schema_path = os\&.path\&.normpath(os\&.path\&.join(os\&.path\&.dirname(__file__), \(aqmanifest\-schema.yml\(aq))
        validator(data, schema_path)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This code validates the manifest against a schema in your plugin folder.
The schema is a \fI\%JSON schema\fP, since bootstrap\-vz
supports \fI\%yaml\fP, you can avoid a lot of curly braces
quotes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$schema: http://json\-schema.org/draft\-04/schema#
title: Example plugin manifest
type: object
properties:
  plugins:
    type: object
    properties:
      example:
        type: object
        properties:
          message: {type: string}
        required: [message]
        additionalProperties: false
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In the schema above we check that the \fBexample\fP plugin has a single property
named \fBmessage\fP with a string value (setting \fBadditionalProperties\fP to \fBfalse\fP
makes sure that users don\(aqt misspell optional attributes).
.SS Internal plugins
.sp
Internal plugins are part of the bootstrap\-vz package and distributed with it.
If you have developed a plugin that you think should be part of the package
because a lot of people might use it you can send a pull request to get it
included (just remember to \fI\%read the guidelines\fP first).
.SS External plugins
.sp
External plugins are packages distributed separately from bootstrap\-vz.
Separate distribution makes sense when your plugin solves a narrow problem scope
specific to your use\-case or when the plugin contains proprietary code that you
would not like to share.
They integrate with bootstrap\-vz by exposing an entry\-point through \fBsetup.py\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
setup(name=\(aqexample\-plugin\(aq,
      version=0.9\&.5,
      packages=find_packages(),
      include_package_data=True,
      entry_points={\(aqbootstrapvz.plugins\(aq: [\(aqplugin_name = package_name.module_name\(aq]},
      install_requires=[\(aqbootstrap\-vz >= 0.9.5\(aq],
      )
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Beyond \fBsetup.py\fP the package might need a \fBMANIFEST.in\fP so that assets
like \fBmanifest\-schema.yml\fP are included when the package is built:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
include example/manifest\-schema.yml
include example/README.rst
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To test your package from source you can run \fBpython setup.py develop\fP
to register the package so that bootstrap\-vz can find the entry\-point of your
plugin.
.sp
An example plugin is available at \fI\%https://github.com/andsens/bootstrap\-vz\-example\-plugin\fP,
you can use it as a starting point for your own plugin.
.SS Installing external plugins
.sp
Some plugins may not find their way to the python package index
(especially if it\(aqs in a private repo). They can of course still be installed
using pip:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install git+ssh://git@github.com/username/repo#egg=plugin_name
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DOCUMENTATION
.sp
Both the end\-user and developer documentation is combined into a single sphinx
build (the two were previously split between github pages and sphinx).
.SS Building
.sp
To build the documentation, simply run \fBtox \-e docs\fP in the project root.
Serving the docs through http can be achieved by subsequently running
\fB(cd docs/_build/html; python \-m SimpleHTTPServer 8080)\fP and accessing them
on \fBhttp://localhost:8080/\fP\&.
.SS READMEs
.sp
Many of the folders in the project have a README.rst which describes
the purpose of the contents in that folder.
These files are automatically included when building the documentation,
through use of the \fI\%include\fP directive.
.sp
Include files for the providers and plugins are autogenerated
through the sphinx conf.py script.
.SS Links
.sp
All links in rst files outside of \fBdocs/\fP (but also \fBdocs/README.rst\fP) that
link to other rst files are relative and reference folder names when the link
would point at a README.rst otherwise. This is done to take advantage of the
github feature where README files are displayed when viewing its parent folder.
When accessing the \fBmanifests/\fP folder for example, the documentation for how
manifests work is displayed at the bottom.
.sp
When sphinx generates the documentation, these relative links are
automatically converted into relative links that work inside the generated
html pages instead.
If you are interested in how this works, take a look at the
link transformation module in \fBdocs/transform_github_links\fP\&.
.SH COMMANDLINE SWITCHES
.sp
As a developer, there are commandline switches available which can
make your life a lot easier.
.INDENT 0.0
.IP \(bu 2
\fB\-\-debug\fP: Enables debug output in the console. This includes output
from all commands that are invoked during bootstrapping.
.IP \(bu 2
\fB\-\-pause\-on\-error\fP: Pauses the execution when an exception occurs
before rolling back. This allows you to debug by inspecting the volume
at the time the error occured.
.IP \(bu 2
\fB\-\-dry\-run\fP: Prevents the \fBrun()\fP function from being called on all
tasks. This is useful if you want to see whether the task order is
correct.
.UNINDENT
.SH TASKOVERVIEW
.SH HOW BOOTSTRAP-VZ WORKS
.SS Tasks
.sp
At its core bootstrap\-vz is based on tasks that perform units of work.
By keeping those tasks small and with a solid structure built around
them a high degree of flexibility can be achieved. To ensure that
tasks are executed in the right order, each task is placed in a
dependency graph where directed edges dictate precedence. Each task is
a simple class that defines its predecessor tasks and successor tasks
via attributes. Here is an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class MapPartitions(Task):
        description = \(aqMapping volume partitions\(aq
        phase = phases\&.volume_preparation
        predecessors = [PartitionVolume]
        successors = [filesystem\&.Format]

        @classmethod
        def run(cls, info):
                info\&.volume\&.partition_map\&.map(info\&.volume)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In this case the attributes define that the task at hand should run
after the \fBPartitionVolume\fP task — i.e. after volume has been
partitioned (\fBpredecessors\fP) — but before formatting each
partition (\fBsuccessors\fP).
It is also placed in the \fBvolume_preparation\fP phase.
Phases are ordered and group tasks together. All tasks in a phase are
run before proceeding with the tasks in the next phase. They are a way
of avoiding the need to list 50 different tasks as predecessors and
successors.
.sp
The final task list that will be executed is computed by enumerating
all tasks in the package, placing them in the graph and
\fI\%sorting them topologically\fP\&.
Subsequently the list returned is filtered to contain only the tasks the
provider and the plugins added to the taskset.
.SS System abstractions
.sp
There are several abstractions in bootstrap\-vz that make it possible
to generalize things like volume creation, partitioning, mounting and
package installation. As a rule these abstractions are located in the
\fBbase/\fP folder, where the manifest parsing and task ordering algorithm
are placed as well.
.SH BASE FUNCTIONALITY
.sp
The base module represents concepts of the bootstrapping process that tasks can interact with
and handles the gather, sorting and running of tasks.
.SS Filesystem handling
.SS Volume
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.volume.Volume(partition_map)
Represents an abstract volume.
This class is a finite state machine and represents the state of the real volume.
.INDENT 7.0
.TP
.B _before_link_dm_node(e)
Links the volume using the device mapper
This allows us to create a \(aqwindow\(aq into the volume that acts like a volume in itself.
Mainly it is used to fool grub into thinking that it is working with a real volume,
rather than a loopback device or a network block device.
.INDENT 7.0
.TP
.B Parameters
\fBe\fP (\fI_e_obj\fP) \-\- Event object containing arguments to create()
.UNINDENT
.sp
Keyword arguments to link_dm_node() are:
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBlogical_start_sector\fP (\fIint\fP) \-\- The sector the volume should start at in the new volume
.IP \(bu 2
\fBstart_sector\fP (\fIint\fP) \-\- The offset at which the volume should begin to be mapped in the new volume
.IP \(bu 2
\fBsectors\fP (\fIint\fP) \-\- The number of sectors that should be mapped
.UNINDENT
.UNINDENT
.sp
Read more at: \fI\%http://manpages.debian.org/cgi\-bin/man.cgi?query=dmsetup&apropos=0&sektion=0&manpath=Debian+7.0+wheezy&format=html&locale=en\fP
.INDENT 7.0
.TP
.B Raises VolumeError
When a free block device cannot be found.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B _before_unlink_dm_node(e)
Unlinks the device mapping
.UNINDENT
.INDENT 7.0
.TP
.B _check_blocking(e)
Checks whether the volume is blocked
.INDENT 7.0
.TP
.B Raises VolumeError
When the volume is blocked from being detached
.UNINDENT
.UNINDENT
.UNINDENT
.SS Partitionmaps
.SS Abstract Partitionmap
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitionmaps.abstract.AbstractPartitionMap(bootloader)
Abstract representation of a partiton map
This class is a finite state machine and represents the state of the real partition map
.INDENT 7.0
.TP
.B _before_map(event)
.INDENT 7.0
.TP
.B Raises PartitionError
In case a partition could not be mapped.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B _before_unmap(event)
.INDENT 7.0
.TP
.B Raises PartitionError
If the a partition cannot be unmapped
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B create(volume)
Creates the partition map
.INDENT 7.0
.TP
.B Parameters
\fBvolume\fP (\fIVolume\fP) \-\- The volume to create the partition map on
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_total_size()
Returns the total size the partitions occupy
.INDENT 7.0
.TP
.B Returns
The size of all partitions
.TP
.B Return type
Sectors
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B is_blocking()
Returns whether the partition map is blocking volume detach operations
.INDENT 7.0
.TP
.B Return type
bool
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B map(volume)
Maps the partition map to device nodes
.INDENT 7.0
.TP
.B Parameters
\fBvolume\fP (\fIVolume\fP) \-\- The volume the partition map resides on
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B unmap(volume)
Unmaps the partition
.INDENT 7.0
.TP
.B Parameters
\fBvolume\fP (\fIVolume\fP) \-\- The volume to unmap the partition map from
.UNINDENT
.UNINDENT
.UNINDENT
.SS GPT Partitionmap
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitionmaps.gpt.GPTPartitionMap(data, sector_size, bootloader)
Represents a GPT partition map
.INDENT 7.0
.TP
.B _before_create(event)
Creates the partition map
.UNINDENT
.UNINDENT
.SS MS\-DOS Partitionmap
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitionmaps.msdos.MSDOSPartitionMap(data, sector_size, bootloader)
Represents a MS\-DOS partition map
Sometimes also called MBR (but that confuses the hell out of me, so ms\-dos it is)
.UNINDENT
.SS No Partitionmap
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitionmaps.none.NoPartitions(data, sector_size, bootloader)
Represents a virtual \(aqNoPartitions\(aq partitionmap.
This virtual partition map exists because it is easier for tasks to
simply always deal with partition maps and then let the base abstract that away.
.INDENT 7.0
.TP
.B get_total_size()
Returns the total size the partitions occupy
.INDENT 7.0
.TP
.B Returns
The size of all the partitions
.TP
.B Return type
Sectors
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B is_blocking()
Returns whether the partition map is blocking volume detach operations
.INDENT 7.0
.TP
.B Return type
bool
.UNINDENT
.UNINDENT
.UNINDENT
.SS Partitions
.SS Abstract partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.abstract.AbstractPartition(size, filesystem, format_command)
Abstract representation of a partiton
This class is a finite state machine and represents the state of the real partition
.INDENT 7.0
.TP
.B _after_mount(e)
Mount any mounts associated with this partition
.UNINDENT
.INDENT 7.0
.TP
.B _before_format(e)
Formats the partition
.UNINDENT
.INDENT 7.0
.TP
.B _before_mount(e)
Mount the partition
.UNINDENT
.INDENT 7.0
.TP
.B _before_unmount(e)
Unmount any mounts associated with this partition
.UNINDENT
.INDENT 7.0
.TP
.B add_mount(source, destination, opts=[])
Associate a mount with this partition
Automatically mounts it
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBsource\fP (\fIstr,AbstractPartition\fP) \-\- The source of the mount
.IP \(bu 2
\fBdestination\fP (\fIstr\fP) \-\- The path to the mountpoint
.IP \(bu 2
\fBopts\fP (\fIlist\fP) \-\- Any options that should be passed to the mount command
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_end()
Gets the end of the partition
.INDENT 7.0
.TP
.B Returns
The end of the partition
.TP
.B Return type
Sectors
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_uuid()
Gets the UUID of the partition
.INDENT 7.0
.TP
.B Returns
The UUID of the partition
.TP
.B Return type
str
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B remove_mount(destination)
Remove a mount from this partition
Automatically unmounts it
.INDENT 7.0
.TP
.B Parameters
\fBdestination\fP (\fIstr\fP) \-\- The mountpoint path of the mount that should be removed
.UNINDENT
.UNINDENT
.UNINDENT
.SS Base partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.base.BasePartition(size, filesystem, format_command, previous)
Represents a partition that is actually a partition (and not a virtual one like \(aqSingle\(aq)
.INDENT 7.0
.TP
.B _before_create(e)
Creates the partition
.UNINDENT
.INDENT 7.0
.TP
.B create(volume)
Creates the partition
.INDENT 7.0
.TP
.B Parameters
\fBvolume\fP (\fIVolume\fP) \-\- The volume to create the partition on
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_index()
Gets the index of this partition in the partition map
.INDENT 7.0
.TP
.B Returns
The index of the partition in the partition map
.TP
.B Return type
int
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B get_start()
Gets the starting byte of this partition
.INDENT 7.0
.TP
.B Returns
The starting byte of this partition
.TP
.B Return type
Sectors
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B map(device_path)
Maps the partition to a device_path
.INDENT 7.0
.TP
.B Parameters
\fBdevice_path\fP (\fIstr\fP) \-\- The device path this partition should be mapped to
.UNINDENT
.UNINDENT
.UNINDENT
.SS GPT partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.gpt.GPTPartition(size, filesystem, format_command, name, previous)
Represents a GPT partition
.UNINDENT
.SS GPT swap partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.gpt_swap.GPTSwapPartition(size, previous)
Represents a GPT swap partition
.UNINDENT
.SS MS\-DOS partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.msdos.MSDOSPartition(size, filesystem, format_command, previous)
Represents an MS\-DOS partition
.UNINDENT
.SS MS\-DOS swap partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.msdos_swap.MSDOSSwapPartition(size, previous)
Represents a MS\-DOS swap partition
.UNINDENT
.SS Single
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.single.SinglePartition(size, filesystem, format_command)
Represents a single virtual partition on an unpartitioned volume
.INDENT 7.0
.TP
.B get_start()
Gets the starting byte of this partition
.INDENT 7.0
.TP
.B Returns
The starting byte of this partition
.TP
.B Return type
Sectors
.UNINDENT
.UNINDENT
.UNINDENT
.SS Unformatted partition
.INDENT 0.0
.TP
.B class bootstrapvz.base.fs.partitions.unformatted.UnformattedPartition(size, previous)
Represents an unformatted partition
It cannot be mounted
.UNINDENT
.SS Exceptions
.INDENT 0.0
.TP
.B exception bootstrapvz.base.fs.exceptions.PartitionError
Raised when an error occurs while interacting with the partitions on the volume
.UNINDENT
.INDENT 0.0
.TP
.B exception bootstrapvz.base.fs.exceptions.VolumeError
Raised when an error occurs while interacting with the volume
.UNINDENT
.SS Package handling
.SS Package list
.INDENT 0.0
.TP
.B class bootstrapvz.base.pkg.packagelist.PackageList(manifest_vars, source_lists)
Represents a list of packages
.INDENT 7.0
.TP
.B class Local(path)
A local package
.UNINDENT
.INDENT 7.0
.TP
.B class PackageList.Remote(name, target)
A remote package with an optional target
.UNINDENT
.INDENT 7.0
.TP
.B PackageList.add(name, target=None)
Adds a package to the install list
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP (\fIstr\fP) \-\- The name of the package to install, may contain manifest vars references
.IP \(bu 2
\fBtarget\fP (\fIstr\fP) \-\- The name of the target release for the package, may contain manifest vars references
.UNINDENT
.TP
.B Raises
.INDENT 7.0
.IP \(bu 2
\fBPackageError\fP \-\- When a package of the same name but with a different target has already been added.
.IP \(bu 2
\fBPackageError\fP \-\- When the specified target release could not be found.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B PackageList.add_local(package_path)
Adds a local package to the installation list
.INDENT 7.0
.TP
.B Parameters
\fBpackage_path\fP (\fIstr\fP) \-\- Path to the local package, may contain manifest vars references
.UNINDENT
.UNINDENT
.UNINDENT
.SS Sources list
.INDENT 0.0
.TP
.B class bootstrapvz.base.pkg.sourceslist.Source(line)
Represents a single source line
.UNINDENT
.INDENT 0.0
.TP
.B class bootstrapvz.base.pkg.sourceslist.SourceLists(manifest_vars)
Represents a list of sources lists for apt
.INDENT 7.0
.TP
.B add(name, line)
Adds a source to the apt sources list
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP (\fIstr\fP) \-\- Name of the file in sources.list.d, may contain manifest vars references
.IP \(bu 2
\fBline\fP (\fIstr\fP) \-\- The line for the source file, may contain manifest vars references
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B target_exists(target)
Checks whether the target exists in the sources list
.INDENT 7.0
.TP
.B Parameters
\fBtarget\fP (\fIstr\fP) \-\- Name of the target to check for, may contain manifest vars references
.TP
.B Returns
Whether the target exists
.TP
.B Return type
bool
.UNINDENT
.UNINDENT
.UNINDENT
.SS Preferences list
.INDENT 0.0
.TP
.B class bootstrapvz.base.pkg.preferenceslist.Preference(preference)
Represents a single preference
.UNINDENT
.INDENT 0.0
.TP
.B class bootstrapvz.base.pkg.preferenceslist.PreferenceLists(manifest_vars)
Represents a list of preferences lists for apt
.INDENT 7.0
.TP
.B add(name, preferences)
Adds a preference to the apt preferences list
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBname\fP (\fIstr\fP) \-\- Name of the file in preferences.list.d, may contain manifest vars references
.IP \(bu 2
\fBpreferences\fP (\fIobject\fP) \-\- The preferences
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Exceptions
.INDENT 0.0
.TP
.B exception bootstrapvz.base.pkg.exceptions.PackageError
Raised when an error occurrs while handling the packageslist
.UNINDENT
.INDENT 0.0
.TP
.B exception bootstrapvz.base.pkg.exceptions.SourceError
Raised when an error occurs while handling the sourceslist
.UNINDENT
.SS Bootstrap information
.INDENT 0.0
.TP
.B class bootstrapvz.base.bootstrapinfo.BootstrapInformation(manifest=None, debug=False)
The BootstrapInformation class holds all information about the bootstrapping process.
The nature of the attributes of this class are rather diverse.
Tasks may set their own attributes on this class for later retrieval by another task.
Information that becomes invalid (e.g. a path to a file that has been deleted) must be removed.
.INDENT 7.0
.TP
.B _BootstrapInformation__create_manifest_vars(manifest, additional_vars={})
Creates the manifest variables dictionary, based on the manifest contents
and additional data.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmanifest\fP (\fIManifest\fP) \-\- The Manifest
.IP \(bu 2
\fBadditional_vars\fP (\fIdict\fP) \-\- Additional values (they will take precedence and overwrite anything else)
.UNINDENT
.TP
.B Returns
The manifest_vars dictionary
.TP
.B Return type
dict
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class bootstrapvz.base.bootstrapinfo.DictClass
Tiny extension of dict to allow setting and getting keys via attributes
.UNINDENT
.SS Manifest
.sp
The Manifest module contains the manifest that providers and plugins use
to determine which tasks should be added to the tasklist, what arguments various
invocations should have etc..
.INDENT 0.0
.TP
.B class bootstrapvz.base.manifest.Manifest(path=None, data=None)
This class holds all the information that providers and plugins need
to perform the bootstrapping process. All actions that are taken originate from
here. The manifest shall not be modified after it has been loaded.
Currently, immutability is not enforced and it would require a fair amount of code
to enforce it, instead we just rely on tasks behaving properly.
.INDENT 7.0
.TP
.B load_data(data=None)
Loads the manifest and performs a basic validation.
This function reads the manifest and performs some basic validation of
the manifest itself to ensure that the properties required for initalization are accessible
(otherwise the user would be presented with some cryptic error messages).
.UNINDENT
.INDENT 7.0
.TP
.B load_modules()
Loads the provider and the plugins.
.UNINDENT
.INDENT 7.0
.TP
.B parse()
Parses the manifest.
Well... "parsing" is a big word.
The function really just sets up some convenient attributes so that tasks
don\(aqt have to access information with info.manifest.data[\(aqsection\(aq]
but can do it with info.manifest.section.
.UNINDENT
.INDENT 7.0
.TP
.B schema_validator(data, schema_path)
This convenience function is passed around to all the validation functions
so that they may run a json\-schema validation by giving it the data and a path to the schema.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdata\fP (\fIdict\fP) \-\- Data to validate (normally the manifest data)
.IP \(bu 2
\fBschema_path\fP (\fIstr\fP) \-\- Path to the json\-schema to use for validation
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B validate()
Validates the manifest using the provider and plugin validation functions.
Plugins are not required to have a validate_manifest function
.UNINDENT
.INDENT 7.0
.TP
.B validation_error(message, data_path=None)
This function is passed to all validation functions so that they may
raise a validation error because a custom validation of the manifest failed.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBmessage\fP (\fIstr\fP) \-\- Message to user about the error
.IP \(bu 2
\fBdata_path\fP (\fIlist\fP) \-\- A path to the location in the manifest where the error occurred
.UNINDENT
.TP
.B Raises ManifestError
With absolute certainty
.UNINDENT
.UNINDENT
.UNINDENT
.SS Tasklist
.sp
The tasklist module contains the TaskList class.
.INDENT 0.0
.TP
.B class bootstrapvz.base.tasklist.TaskList(tasks)
The tasklist class aggregates all tasks that should be run
and orders them according to their dependencies.
.INDENT 7.0
.TP
.B run(info, dry_run=False)
Converts the taskgraph into a list and runs all tasks in that list
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBinfo\fP (\fIdict\fP) \-\- The bootstrap information object
.IP \(bu 2
\fBdry_run\fP (\fIbool\fP) \-\- Whether to actually run the tasks or simply step through them
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.check_ordering(task)
Checks the ordering of a task in relation to other tasks and their phases.
.sp
This function checks for a subset of what the strongly connected components algorithm does,
but can deliver a more precise error message, namely that there is a conflict between
what a task has specified as its predecessors or successors and in which phase it is placed.
.INDENT 7.0
.TP
.B Parameters
\fBtask\fP (\fITask\fP) \-\- The task to check the ordering for
.TP
.B Raises TaskListError
If there is a conflict between task precedence and phase precedence
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.create_list(taskset, all_tasks)
Creates a list of all the tasks that should be run.
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.get_all_classes(path=None, prefix=\(aq\(aq, excludes=[])
Given a path to a package, this function retrieves all the classes in it
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBpath\fP (\fIstr\fP) \-\- Path to the package
.IP \(bu 2
\fBprefix\fP (\fIstr\fP) \-\- Name of the package followed by a dot
.IP \(bu 2
\fBexcludes\fP (\fIlist\fP) \-\- List of str matching module names that should be ignored
.UNINDENT
.TP
.B Returns
A generator that yields classes
.TP
.B Return type
generator
.TP
.B Raises Exception
If a module cannot be inspected.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.get_all_tasks(modules)
Gets a list of all task classes in the package
.INDENT 7.0
.TP
.B Returns
A list of all tasks in the package
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.load_tasks(function, manifest, *args)
Calls \fBfunction\fP on the provider and all plugins that have been loaded by the manifest.
Any additional arguments are passed directly to \fBfunction\fP\&.
The function that is called shall accept the taskset as its first argument and the manifest
as its second argument.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfunction\fP (\fIstr\fP) \-\- Name of the function to call
.IP \(bu 2
\fBmanifest\fP (\fIManifest\fP) \-\- The manifest
.IP \(bu 2
\fBargs\fP (\fIlist\fP) \-\- Additional arguments that should be passed to the function that is called
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.strongly_connected_components(graph)
Find the strongly connected components in a graph using Tarjan\(aqs algorithm.
.sp
Source: \fI\%http://www.logarithmic.net/pfh\-files/blog/01208083168/sort.py\fP
.INDENT 7.0
.TP
.B Parameters
\fBgraph\fP (\fIdict\fP) \-\- mapping of tasks to lists of successor tasks
.TP
.B Returns
List of tuples that are strongly connected comoponents
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.tasklist.topological_sort(graph)
Runs a topological sort on a graph.
.sp
Source: \fI\%http://www.logarithmic.net/pfh\-files/blog/01208083168/sort.py\fP
.INDENT 7.0
.TP
.B Parameters
\fBgraph\fP (\fIdict\fP) \-\- mapping of tasks to lists of successor tasks
.TP
.B Returns
A list of all tasks in the graph sorted according to ther dependencies
.TP
.B Return type
list
.UNINDENT
.UNINDENT
.SS Logging
.sp
This module holds functions and classes responsible for formatting the log output
both to a file and to the console.
.INDENT 0.0
.TP
.B class bootstrapvz.base.log.ColorFormatter(fmt=None, datefmt=None)
Colorizes log messages depending on the loglevel
.UNINDENT
.INDENT 0.0
.TP
.B class bootstrapvz.base.log.FileFormatter(fmt=None, datefmt=None)
Formats log statements for output to file
Currently this is just a stub
.UNINDENT
.INDENT 0.0
.TP
.B class bootstrapvz.base.log.SourceFormatter(fmt=None, datefmt=None)
Adds a [source] tag to the log message if it exists
The python docs suggest using a LoggingAdapter, but that would mean we\(aqd
have to use it everywhere we log something (and only when called remotely),
which is not feasible.
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.log.get_console_handler(debug, colorize)
Returns a log handler for the console
The handler color codes the different log levels
.INDENT 7.0
.TP
.B Params bool debug
Whether to set the log level to DEBUG (otherwise INFO)
.TP
.B Params bool colorize
Whether to colorize console output
.TP
.B Returns
The console logging handler
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.log.get_file_handler(path, debug)
Returns a log handler for the given path
If the parent directory of the logpath does not exist it will be created
The handler outputs relative timestamps (to when it was created)
.INDENT 7.0
.TP
.B Params str path
The full path to the logfile
.TP
.B Params bool debug
Whether to set the log level to DEBUG (otherwise INFO)
.TP
.B Returns
The file logging handler
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B bootstrapvz.base.log.get_log_filename(manifest_path)
Returns the path to a logfile given a manifest
The logfile name is constructed from the current timestamp and the basename of the manifest
.INDENT 7.0
.TP
.B Parameters
\fBmanifest_path\fP (\fIstr\fP) \-\- The path to the manifest
.TP
.B Returns
The path to the logfile
.TP
.B Return type
str
.UNINDENT
.UNINDENT
.SS Task
.INDENT 0.0
.TP
.B class bootstrapvz.base.task.Task
The task class represents a task that can be run.
It is merely a wrapper for the run function and should never be instantiated.
.INDENT 7.0
.TP
.B classmethod run(info)
The run function, all work is done inside this function
.INDENT 7.0
.TP
.B Parameters
\fBinfo\fP (\fIBootstrapInformation\fP) \-\- The bootstrap info object.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Phase
.INDENT 0.0
.TP
.B class bootstrapvz.base.phase.Phase(name, description)
The Phase class represents a phase a task may be in.
It has no function other than to act as an anchor in the task graph.
All phases are instantiated in common.phases
.INDENT 7.0
.TP
.B pos()
Gets the position of the phase
.INDENT 7.0
.TP
.B Returns
The positional index of the phase in relation to the other phases
.TP
.B Return type
int
.UNINDENT
.UNINDENT
.UNINDENT
.SH COMMON
.sp
The common module contains features that are common to multiple providers and plugins.
It holds both a large set of shared tasks and also various tools that are used by both
the base module and tasks.
.SS Volume representations
.SS Shared tasks
.SH UNIT TESTS
.SH INTEGRATION TESTS
.sp
\fI\%Integration tests\fP test
bootstrap\-vz in its entirety.
This testing includes building images from manifests and
creating/booting said images.
.sp
Since hardcoding manifests for each test, bootstrapping them and booting the
resulting images is too much code for a single test, a testing harness has
been developed that reduces each test to it\(aqs bare essentials:
.INDENT 0.0
.IP \(bu 2
Combine available \fI\%manifest partials\fP into a single manifest
.IP \(bu 2
Boot an instance from a manifest
.IP \(bu 2
Run tests on the booted instance
.UNINDENT
.sp
In order for the integration testing harness to be able to bootstrap it must
know about your \fI\%build\-servers\fP\&.
Depending on the manifest that is bootstrapped, the harness chooses
a fitting build\-server, connects to it and starts the bootstrapping process.
.sp
When running integration tests, the framework will look for \fBbuild\-servers.yml\fP
at the root of the repo and raise an error if it is not found.
.SS Manifest combinations
.sp
The tests mainly focus on varying key parts of an image
(e.g. partitioning, Debian release, bootloader, ec2 backing, ec2 virtualization method)
that have been problem areas.
Essentially the tests are the cartesian product of these key parts.
.SS Aborting a test
.sp
You can press \fBCtrl+C\fP at any time during the testing to abort \-
the harness will automatically clean up any temporary resources and shut down
running instances. Pressing \fBCtrl+C\fP a second time stops the cleanup and quits
immediately.
.SS Manifest partials
.sp
Instead of creating manifests from scratch for each single test, reusable parts
are factored out into partials in the manifest folder.
This allows code like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
partials = {\(aqvdi\(aq: \(aq{provider: {name: virtualbox}, volume: {backing: vdi}}\(aq,
            \(aqvmdk\(aq: \(aq{provider: {name: virtualbox}, volume: {backing: vmdk}}\(aq,
            }

def test_unpartitioned_extlinux_oldstable():
        std_partials = [\(aqbase\(aq, \(aqstable64\(aq, \(aqextlinux\(aq, \(aqunpartitioned\(aq, \(aqroot_password\(aq]
        custom_partials = [partials[\(aqvmdk\(aq]]
        manifest_data = merge_manifest_data(std_partials, custom_partials)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The code above produces a manifest for Debian stable 64\-bit unpartitioned
virtualbox VMDK image.
\fBroot_password\fP is a special partial in that the actual password is
randomly generated on load.
.SS Missing parts
.sp
The integration testing harness is in no way complete.
.INDENT 0.0
.IP \(bu 2
It still has no support for providers other than virtualbox and EC2.
.IP \(bu 2
Creating an SSH connection to a booted instance is cumbersome and does not
happen in any of the tests \- this would be particularly useful when manifests
are to be tested beyond whether they boot up.
.UNINDENT
.SH INTEGRATION TEST PROVIDERS
.sp
The testing framework consists of two parts:
The unit tests and the integration tests.
.sp
The \fI\%unit tests\fP are responsible for testing individual
parts of bootstrap\-vz, while the \fI\%integration tests\fP test
entire manifests by bootstrapping and booting them.
.SH SELECTING TESTS
.sp
To run one specific test suite simply append the module path to tox:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ tox \-e unit tests.unit.releases_tests
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Specific tests can be selected by appending the function name with a colon
to the modulepath \-\- to run more than one tests, simply attach more arguments.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ tox \-e unit tests.unit.releases_tests:test_lt tests.unit.releases_tests:test_eq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
bootstrap\-vz is a bootstrapping framework for Debian that creates ready\-to\-boot
images able to run on a number of cloud providers and virtual machines.
bootstrap\-vz runs without any user intervention and
generates ready\-to\-boot images for a number of virtualization
platforms.
Its aim is to provide a reproducable bootstrapping process using
\fI\%manifests\fP
as well as supporting a high degree of customizability through plugins.
.sp
bootstrap\-vz was coded from scratch in python once the bash script
architecture that was used in the
\fI\%build\-debian\-cloud\fP
bootstrapper reached its limits.
.SH DOCUMENTATION
.sp
The documentation for bootstrap\-vz is available at
\fI\%bootstrap\-vz.readthedocs.org\fP\&.
There, you can discover \fI\%what the dependencies\fP for
a specific cloud provider are, \fI\%see a list of available plugins\fP
and learn \fI\%how you create a manifest\fP\&.
.sp
Note to developers: \fI\%The documentaion\fP is generated in
a rather peculiar and nifty way.
.SH INSTALLATION
.sp
bootstrap\-vz has a master branch for stable releases and a development
for, well, development.
.sp
After checking out the branch of your choice you can install the
python dependencies by running \fBpython setup.py install\fP\&. However,
depending on what kind of image you\(aqd like to bootstrap, there are
other debian package dependencies as well, at the very least you will
need \fBdebootstrap\fP\&.
\fI\%The documentation\fP
explains this in more detail.
.sp
Note that bootstrap\-vz will tell you which tools it requires when they
aren\(aqt present (the different packages are mentioned in the error
message), so you can simply run bootstrap\-vz once to get a list of the
packages, install them, and then re\-run.
.SH QUICK START
.sp
Here are a few quickstart tutorials for the most common images.
If you plan on partitioning your volume, you will need the \fBparted\fP
package and \fBkpartx\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
root@host:~# apt\-get install parted kpartx
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that you can always abort a bootstrapping process by pressing
\fBCtrl+C\fP, bootstrap\-vz will then initiate a cleanup/rollback process,
where volumes are detached/deleted and temporary files removed, pressing
\fBCtrl+C\fP a second time shortcuts that procedure, halts the cleanup and
quits the process.
.SS VirtualBox Vagrant
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
user@host:~$ sudo \-i # become root
root@host:~# git clone https://github.com/andsens/bootstrap\-vz.git # Clone the repo
root@host:~# apt\-get install qemu\-utils debootstrap python\-pip # Install dependencies from aptitude
root@host:~# pip install termcolor jsonschema fysom docopt pyyaml # Install python dependencies
root@host:~# bootstrap\-vz/bootstrap\-vz bootstrap\-vz/manifests/virtualbox\-vagrant.manifest.yml
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to use the \fI\%minimize_size\fP plugin,
you will have to install the \fBzerofree\fP package and \fI\%VMWare Workstation\fP as well.
.SS Amazon EC2 EBS backed AMI
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
user@host:~$ sudo \-i # become root
root@host:~# git clone https://github.com/andsens/bootstrap\-vz.git # Clone the repo
root@host:~# apt\-get install debootstrap python\-pip # Install dependencies from aptitude
root@host:~# pip install termcolor jsonschema fysom docopt pyyaml boto # Install python dependencies
root@host:~# bootstrap\-vz/bootstrap\-vz bootstrap\-vz/manifests/ec2\-ebs\-debian\-official\-amd64\-pvm.manifest.yml
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To bootstrap S3 backed AMIs, bootstrap\-vz will also need the
\fBeuca2ools\fP package. However, version 3.2.0 is required meaning you
must however install it directly from the eucalyptus repository like
this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
apt\-get install \-\-no\-install\-recommends python\-dev libxml2\-dev libxslt\-dev gcc
pip install git+git://github.com/eucalyptus/euca2ools.git@v3.2.0
.ft P
.fi
.UNINDENT
.UNINDENT
.SH CLEANUP
.sp
bootstrap\-vz tries very hard to clean up after itself both if a run was
successful but also if it failed. This ensures that you are not left
with volumes still attached to the host which are useless. If an error
occurred you can simply correct the problem that caused it and rerun
everything, there will be no leftovers from the previous run (as always
there are of course rare/unlikely exceptions to that rule). The error
messages should always give you a strong hint at what is wrong, if that
is not the case please consider \fI\%opening an issue\fP and attach
both the error message and your manifest (preferably as a gist or
similar).
.SH DEPENDENCIES
.sp
bootstrap\-vz has a number of dependencies depending on the target
platform and \fI\%the selected plugins\fP\&.
At a bare minimum the following python libraries are needed:
.INDENT 0.0
.IP \(bu 2
\fI\%termcolor\fP
.IP \(bu 2
\fI\%fysom\fP
.IP \(bu 2
\fI\%jsonschema\fP
.IP \(bu 2
\fI\%docopt\fP
.IP \(bu 2
\fI\%pyyaml\fP
.UNINDENT
.sp
To bootstrap Debian itself \fI\%debootstrap\fP is needed as well.
.sp
Any other requirements are dependent upon the manifest configuration
and are detailed in the corresponding sections of the documentation.
bootstrap\-vz will however warn you if a requirement has not been met,
before the bootstrapping process begins.
.SH DEVELOPERS
.sp
The API documentation, development guidelines and an explanation of
bootstrap\-vz internals can be found at \fI\%bootstrap\-vz.readthedocs.org\fP\&.
.SH CONTRIBUTING
.sp
Contribution guidelines are described in the documentation under \fI\%Contributing\fP\&.
There\(aqs also a topic regarding \fI\%the coding style\fP\&.
.SH AUTHOR
Anders Ingemann
.SH COPYRIGHT
2014, Anders Ingemann
.\" Generated by docutils manpage writer.
.
